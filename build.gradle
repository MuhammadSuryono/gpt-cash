buildscript {
    repositories {
        mavenCentral()
        maven { url 'https://repo.spring.io/plugins-release' }
        
    }
    dependencies {
        classpath("io.spring.gradle:dependency-management-plugin:1.0.3.RELEASE")
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.8.RELEASE")
        classpath("org.springframework.build.gradle:propdeps-plugin:0.0.7")
    }
}

plugins {
  id "org.sonarqube" version "2.6"
}

sonarqube {
    properties {
        property "sonar.sourceEncoding", "UTF-8"
    }
}

ext['hibernate.version'] = '5.2.10.Final'
ext['hazelcast.version'] = '3.9'

//ext['spring-security.version'] = '5.1.2.RELEASE'

allprojects {
    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'maven'
    apply plugin: 'propdeps-eclipse'

    def artifactId
    ext.buildProperties = new Properties()
    File fileProps = file("properties.gradle")
    if(fileProps.exists()) {
        buildProperties.load(new FileInputStream(fileProps))
    }

    artifactId = buildProperties['artifactId']
    if(artifactId != null) {
        jar.baseName = artifactId
        if(tasks.findByPath('war') != null) {
            war.baseName = artifactId
        }
    }

    if(buildProperties['group'] != null) 
        group = buildProperties['group']
    else
        group = rootProject.group
        
    if(buildProperties['version'] != null) 
        version = buildProperties['version']
    else
        version = rootProject.version

	def releaseVersion = true
	
	if(version.endsWith('WIP')) {
	    version = version[0..-5];
	    version += '-' + new Date().format('yyyyMMdd') + '-SNAPSHOT'
	    releaseVersion = false
	}

	configurations {
	    modularConfiguration
	}
    
    repositories {
        maven { 
            url mavenAll 
        }
 
        //maven {	url 'https://repo1.maven.org/maven2/' }
               maven {	url 'https://jaspersoft.jfrog.io/jaspersoft/third-party-ce-artifacts' }
        mavenLocal()
    }
    
	sourceSets {
	    main {
	        java {
	            srcDir 'src'
	        }
	        
	        resources {
	            srcDir 'resources'
	        }
	    }
	}
    
    compileJava {
        sourceCompatibility = '1.8'
        targetCompatibility = '1.8'
        options.fork = true
        options.forkOptions.executable = 'javac'
        options.compilerArgs << "-XDignore.symbol.file"
    }
    
	ext.repositoryURL = null
	gradle.taskGraph.whenReady {taskGraph ->
	    if(taskGraph.hasTask(uploadArchivesLocal)) {
	        repositories.each {
	            if(it.name.equals('MavenLocal')) {
	                repositoryURL = it.url
	            }
	        }
	    }
	    
	    if(repositoryURL == null) {
	        if(releaseVersion) {
	            repositoryURL = releasesRepository
	        } else
	            repositoryURL = snapshotsRepository
	    }
	}
	
	gradle.taskGraph.beforeTask { Task aTask ->
	    if (aTask == uploadArchives) { 
	        aTask.repositories.mavenDeployer.repository(url: repositoryURL) {
	            authentication(userName: repo_username, password: repo_password)
	        }
	    }
	}    
	
	uploadArchives {
		repositories {
		    mavenDeployer {
		      if(artifactId != null)
        		      pom.artifactId = artifactId
		    }
		}
	}
	
	task uploadArchivesLocal(dependsOn: uploadArchives) {
	    description 'The same as uploadArchives, except it only deploys to local repository instead of central respository'
	    group 'upload'
	}
    
}

configurations {
    modules
}

dependencies {
      
    modularConfiguration(
    	//[group: 'io.jsonwebtoken',     name: 'jjwt',                version: '0.9.1'],
    	//[group: 'org.springframework.boot',     name: 'spring-boot-starter-security',                version: '2.5.0'],
        [group: 'org.springframework.data',     name: 'spring-data-jpa',                version: '1.11.6.RELEASE'],
        [group: 'org.springframework.security', name: 'spring-security-web',            version: '4.2.3.RELEASE'],
        [group: 'org.springframework.security', name: 'spring-security-config',         version: '4.2.3.RELEASE'],
        
        [group: 'org.hibernate',                name: 'hibernate-core',                 version: project.ext['hibernate.version']],
        [group: 'org.codehaus.jackson',         name: 'jackson-mapper-asl',             version: '1.9.13'],
        [group: 'com.netflix.hystrix',          name: 'hystrix-core',                   version: '1.5.12'],
        [group: 'com.netflix.archaius',         name: 'archaius-core',                  version: '0.7.4'],
        
        [group: 'de.ruedigermoeller',           name: 'fst',                            version: '2.54'],

        [group: 'com.gpt.component',            name: 'common',                         version: '1.0.4'],
        
        [group: 'com.gpt.component',            name: 'json',                           version: '1.0.0'],
        [group: 'com.gpt.component',            name: 'encryption',                     version: '1.0.0'],
        [group: 'net.sf.jasperreports',         name: 'jasperreports',                  version: '6.4.3'],        
        [group: 'org.apache.poi',     			name: 'poi',          					version: '3.17']
    )
    
    modularConfiguration(group: 'org.quartz-scheduler',  name: 'quartz',                         version: '2.3.0') {
        exclude group: 'com.zaxxer'
        exclude group: 'com.mchange'
    }
    modularConfiguration(group: 'com.hazelcast',         name: 'hazelcast-spring',               version: project.ext['hazelcast.version']) {
        exclude group: 'com.hazelcast',     module: 'hazelcast'
    }
    modularConfiguration(group: 'com.hazelcast',         name: 'hazelcast-hibernate52',          version: '1.2.1') {
        exclude group: 'com.hazelcast',     module: 'hazelcast'
    }

    provided files("configs")
    
	File listModules = file("modules.gradle")
	if(listModules.exists()) {
	    listModules.each {
	       modules(it) {
               subprojects.each {
                    // exclude all dependencies to any of subprojects
                    exclude group: group, module: it.jar.baseName 
               }
           }	       
	    }
	}
	    
	configurations.modules.getResolvedConfiguration().getResolvedArtifacts().each {
	   def artifact = it.artifactId.getComponentIdentifier().getDisplayName()
	   if(!artifact.startsWith('com.gpt.platform') && !artifact.startsWith('com.gpt.product')) {
	       modularConfiguration(artifact) {
               transitive = false
	       }
       }
	} 

    compile configurations.modules.allDependencies
	compile configurations.modularConfiguration.allDependencies
}

//jar.enabled = false
//uploadArchives.enabled = false

task wrapper(type: Wrapper) {
    gradleVersion = '3.4'
}

/**
 * Deployment preparation
 */
task buildDeployment {
    group 'build'
    description 'Prepare all modules and configs required for deployment'
    
    subprojects.each { thisProject ->
        dependsOn thisProject.build
    }
    
    def springbootProject = project(":platform-springboot")
    
    doLast {
        def targetDir = "$buildDir/deployments"
        
	    delete fileTree(targetDir)  
        
        // for each external module platform or product that this project depends on
        configurations.modules.getResolvedConfiguration().getResolvedArtifacts().each { artifact ->
            def artifactId = artifact.artifactId.getComponentIdentifier().getDisplayName()
            if(artifactId.startsWith('com.gpt.platform') || artifactId.startsWith('com.gpt.product')) {
	            ant.copy(todir:"$targetDir/modules", overwrite: true, preservelastmodified: true) {
	                fileset (file: artifact.file)            
	            }
	        }
	    }
        
        // for each module found
        subprojects.each { thisProject ->
            if(thisProject != springbootProject && !springbootProject.subprojects.contains(thisProject)) {
	            thisProject.configurations.archives.allArtifacts.each { artifact ->
	                // copy to folder modules
	                ant.copy(todir:"$targetDir/modules", overwrite: true, preservelastmodified: true) {
	                    fileset (file: artifact.file)                     
	                }
	            }
	            
                // copy to folder configs
                ant.copy(todir:"$targetDir/configs/$thisProject.name", overwrite: true, preservelastmodified: true, quiet: true, failonerror: false) {
                    fileset (dir: thisProject.projectDir.path + '/configs', excludes: '_*.*')
                }
	        } else {
                thisProject.configurations.archives.allArtifacts.each { artifact ->
                    // copy to root folder
                    ant.copy(todir:"$targetDir", overwrite: true, preservelastmodified: true) {
                        fileset (file: artifact.file)                     
                    }
                }
                
                ant.copy(todir:"$targetDir/configs", overwrite: true, preservelastmodified: true) {
                    fileset (file: file(thisProject.projectDir.path + '/application.properties'))                     
                }
	        }
        }
        
        // copy configs from root project
        ant.copy(todir:"$targetDir/configs", overwrite: true, preservelastmodified: true, quiet: true, failonerror: false) {
            fileset (dir: project.projectDir.path + '/configs', excludes: '_*.*, reloadTrigger, *.bak')
        }
        
    }
}


