package com.gpt.product.gpcash.corporate.transaction.report.trxsummary.services;

import java.io.File;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.gpt.component.common.exceptions.ApplicationException;
import com.gpt.component.common.exceptions.BusinessException;
import com.gpt.component.maintenance.sysparam.SysParamConstants;
import com.gpt.component.maintenance.sysparam.repository.SysParamRepository;
import com.gpt.platform.cash.constants.ApplicationConstants;
import com.gpt.platform.cash.utils.DateUtils;
import com.gpt.product.gpcash.corporate.transaction.globaltransaction.repository.GlobalTransactionRepository;
import com.gpt.product.gpcash.corporate.transaction.report.trxsummary.bean.TrxSummaryBean;
import com.gpt.product.gpcash.pendingdownload.services.PendingDownloadService;
import com.gpt.product.gpcash.service.repository.ServiceRepository;

import net.sf.jasperreports.engine.JREmptyDataSource;
import net.sf.jasperreports.engine.JasperExportManager;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.JasperReport;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import net.sf.jasperreports.engine.export.JRXlsExporter;
import net.sf.jasperreports.engine.util.JRLoader;
import net.sf.jasperreports.export.SimpleExporterInput;
import net.sf.jasperreports.export.SimpleOutputStreamExporterOutput;
import net.sf.jasperreports.export.SimpleXlsxReportConfiguration;

@Service
@Transactional(rollbackFor = Exception.class)
public class TrxSummaryReportServiceImpl implements TrxSummaryReportService {
	private final Logger logger = LoggerFactory.getLogger(getClass());
	
	@Value("${gpcash.report.folder}")
	private String reportFolder;
	
	@Value("${gpcash.temp.download.path}")
	private String pathDownload;
	
	@Autowired
	private ServiceRepository serviceRepo;
	
	@Autowired
	private SysParamRepository sysParamRepo;
	
	@Autowired
	private GlobalTransactionRepository globalTransactionRepo;
	
	@Autowired
	private PendingDownloadService pendingDownloadService;
	
	Locale locale = LocaleContextHolder.getLocale();
	
	@Override
	public Map<String, Object> downloadReport(Map<String, Object> map, String requestBy) throws ApplicationException {
		try {
			String downloadId = (String) map.get("downloadId");
			return pendingDownloadService.downloadReport(downloadId, requestBy);
		} catch (Exception e) {
			throw new ApplicationException(e);
		}
	}
	
	@Override
	public void doGenerateReport(Map<String, Object> map, String requestBy) throws ApplicationException, BusinessException {
		String downloadId = (String) map.get("downloadId");
		
		try {
			//update report to in progress
			pendingDownloadService.updateToInProgress(downloadId);
			//-----------------------------
			
			Date fromDate = (Date) map.get("fromDate");
			Date toDate = (Date) map.get("toDate");
			String fileFormat = (String) map.get("fileFormat");
			String fileName = (String) map.get(ApplicationConstants.FILENAME);
			
			SimpleDateFormat sdfDateTime = new SimpleDateFormat("dd MMM yyyy HH:mm:ss");
			SimpleDateFormat sdfDate = new SimpleDateFormat("dd MMM yyyy");

			Calendar startDate = DateUtils.getEarliestDate(fromDate);
			startDate.set(Calendar.HOUR_OF_DAY, 0);
			startDate.set(Calendar.MINUTE, 0);
			startDate.set(Calendar.SECOND, 0);
			startDate.set(Calendar.MILLISECOND, 0);
			
			
			Calendar endDate = DateUtils.getNextEarliestDate(toDate);
			endDate.set(Calendar.HOUR_OF_DAY, 0);
			endDate.set(Calendar.MINUTE, 0);
			endDate.set(Calendar.SECOND, 0);
			endDate.set(Calendar.MILLISECOND, 0);
			
			java.sql.Date startDateSql = new java.sql.Date(startDate.getTimeInMillis());
			java.sql.Date endDateSql = new java.sql.Date(endDate.getTimeInMillis());
			
			Map<String, Object> reportInfo = getReportParams(fileFormat, startDateSql, endDateSql);

			String generateInfo = "generated by ".concat(requestBy).concat(" on ").concat(sdfDateTime.format(DateUtils.getCurrentTimestamp()));
			String periods = "Order Period ".concat(sdfDate.format(fromDate)).concat(" - ").concat(sdfDate.format(toDate));
			
			reportInfo.put("generateInfo", generateInfo);
			reportInfo.put("periods", periods);
	        
			String destinationFile = pathDownload + File.separator + fileName;
			generateReport(reportInfo, destinationFile, fileFormat);
			
			pendingDownloadService.updateToComplete(downloadId, destinationFile);
			
		} catch (BusinessException e) {
			pendingDownloadService.updateToNewRequest(downloadId);
			logger.error("Failed to generateReport with downloadId " + downloadId + " " + e.getMessage(),e);
		} catch (Exception e) {
			pendingDownloadService.updateToNewRequest(downloadId);
			logger.error("Failed to generateReport with downloadId " + downloadId + " " + e.getMessage(),e);
		}
	}
	
	private Map<String, Object> getReportParams(String fileFormat, java.sql.Date startDate, java.sql.Date endDate) throws Exception{
		HashMap<String, Object> reportParams = new HashMap<>();
		
		List<Object[]> services = serviceRepo.findServiceByServiceType(ApplicationConstants.SERVICE_TYPE_TRX);
		
		String equivalentCurrency = sysParamRepo.getOne(SysParamConstants.LOCAL_CURRENCY_CODE).getValue();
		
		List<TrxSummaryBean> detailDSList = new ArrayList<>();
		int grantTotalSuccess = 0;
		int grandTotalFailed = 0;
		BigDecimal grantTotalSuccessAmount = BigDecimal.ZERO;
		BigDecimal grantTotalFailedAmount = BigDecimal.ZERO;
		if(services.size() > 0) {
			TrxSummaryBean trxSummary = null;
			int record = 1;
			for (Object[] serviceArr : services) {
				trxSummary = new TrxSummaryBean();
				
				String serviceCode = (String) serviceArr[0];
				String serviceName = (String) serviceArr[1];
				
				trxSummary.setFileFormat(fileFormat);
				trxSummary.setNo(String.valueOf(record));
				
				trxSummary.setService(serviceName);
				
				//success info
				trxSummary.setSuccessCurrency(equivalentCurrency);
				int success = globalTransactionRepo.countSuccessByServiceCode(serviceCode, startDate, endDate);
				trxSummary.setSuccess(String.valueOf(success));
				grantTotalSuccess = grantTotalSuccess + success;
				
				BigDecimal successAmount = globalTransactionRepo.sumSuccessByServiceCode(serviceCode, startDate, endDate);
				if(successAmount == null) {
					successAmount = BigDecimal.ZERO;
				}
				trxSummary.setSuccessAmount(successAmount.toPlainString());
				grantTotalSuccessAmount = grantTotalSuccessAmount.add(successAmount);
				
				//failed info
				trxSummary.setFailedCurrency(equivalentCurrency);
				int failed = globalTransactionRepo.countFailedByServiceCode(serviceCode, startDate, endDate);
				trxSummary.setFailed(String.valueOf(failed));
				grandTotalFailed = grandTotalFailed + failed;
				
				BigDecimal failedAmount = globalTransactionRepo.sumFailedByServiceCode(serviceCode, startDate, endDate);
				if(failedAmount == null) {
					failedAmount = BigDecimal.ZERO;
				}
				trxSummary.setFailedAmount(failedAmount.toPlainString());
				grantTotalFailedAmount = grantTotalFailedAmount.add(failedAmount);
				
				trxSummary.setTotalTransaction(String.valueOf(success + failed));
				
				detailDSList.add(trxSummary);
				record++;
			}
		}
		
		JRBeanCollectionDataSource detailDataSource= new JRBeanCollectionDataSource(detailDSList);
		reportParams.put("detailDataSource", detailDataSource);
		reportParams.put("grandTotalSuccess", String.valueOf(grantTotalSuccess));
		reportParams.put("grandTotalFailed", String.valueOf(grandTotalFailed));
		reportParams.put("grandTotalTrx", String.valueOf(grantTotalSuccess + grandTotalFailed));
		reportParams.put("grandTotalSuccessAmount", grantTotalSuccessAmount.toPlainString());
		reportParams.put("grandTotalFailedAmount", grantTotalFailedAmount.toPlainString());
		
		//-----------------------
		
		return reportParams;
	}
	
	private void generateReport(Map<String, Object> parameters,
			String destinationFile,
			String fileFormat) throws Exception {
		
		String masterReportFile = reportFolder + File.separator + "BankReport" + File.separator + "TrxSummary" + File.separator + "trxsummary" + "-" + locale.getLanguage() + ".jasper";;
		JasperReport masterReport = (JasperReport) JRLoader.loadObject(new File(masterReportFile));
		
		//put subReport and fileFormat
		parameters.put("fileFormat", fileFormat);
		
		JasperPrint print = JasperFillManager.fillReport(masterReport, parameters, new JREmptyDataSource());
		
		
		Path destinationFilePath = Paths.get(destinationFile);
		
		if(fileFormat.equals(ApplicationConstants.FILE_FORMAT_PDF)) {
			byte[] bytes = JasperExportManager.exportReportToPdf(print);
			
			//write files
			Files.write(destinationFilePath, bytes);
		} else {
            JRXlsExporter xlsExporter = new JRXlsExporter();
            xlsExporter.setExporterInput(new SimpleExporterInput(print));
            xlsExporter.setExporterOutput(new SimpleOutputStreamExporterOutput(destinationFilePath.toFile()));
            SimpleXlsxReportConfiguration xlsReportConfiguration = new SimpleXlsxReportConfiguration();
            xlsReportConfiguration.setOnePagePerSheet(false);
            xlsReportConfiguration.setDetectCellType(true);
            xlsReportConfiguration.setWhitePageBackground(false);
            xlsReportConfiguration.setShowGridLines(false);
            xlsExporter.setConfiguration(xlsReportConfiguration);
            xlsExporter.exportReport();
		}
	}
}