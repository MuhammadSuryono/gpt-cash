package com.gpt.product.gpcash.corporate.transaction.report.domtrxreport.services;

import java.io.File;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Timestamp;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.codehaus.jackson.map.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.gpt.component.common.exceptions.ApplicationException;
import com.gpt.component.common.exceptions.BusinessException;
import com.gpt.platform.cash.constants.ApplicationConstants;
import com.gpt.platform.cash.utils.DateUtils;
import com.gpt.product.gpcash.corporate.pendingtaskuser.model.CorporateUserPendingTaskModel;
import com.gpt.product.gpcash.corporate.transaction.domestic.model.DomesticTransferModel;
import com.gpt.product.gpcash.corporate.transaction.domestic.repository.DomesticTransferCustomRepository;
import com.gpt.product.gpcash.corporate.transaction.domestic.repository.DomesticTransferRepository;
import com.gpt.product.gpcash.corporate.transaction.report.domtrxreport.bean.DomReportBean;
import com.gpt.product.gpcash.pendingdownload.services.PendingDownloadService;
import com.gpt.product.gpcash.service.repository.ServiceRepository;

import net.sf.jasperreports.engine.JREmptyDataSource;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.JasperReport;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import net.sf.jasperreports.engine.export.JRXlsExporter;
import net.sf.jasperreports.engine.util.JRLoader;
import net.sf.jasperreports.export.SimpleExporterInput;
import net.sf.jasperreports.export.SimpleOutputStreamExporterOutput;
import net.sf.jasperreports.export.SimpleXlsxReportConfiguration;

@Service
@Transactional(rollbackFor = Exception.class)
public class DomesticReportServiceImpl implements DomesticReportService{
	private final Logger logger = LoggerFactory.getLogger(getClass());
	
	@Value("${gpcash.report.folder}")
	private String reportFolder;
	
	@Value("${gpcash.temp.download.path}")
	private String pathDownload;
	
	@Value("${gpcash.report.money.format:#,###.00}")
	private String moneyFormat;
	
	@Autowired
	private ServiceRepository serviceRepo;
	
	@Autowired
	private DomesticTransferCustomRepository domeRepo;
	
	@Autowired
	private PendingDownloadService pendingDownloadService;
	
	@Autowired
	private MessageSource message;
	
	@Autowired
	private ObjectMapper objectMapper;
	
	@Autowired
	private DomesticTransferRepository domTransferRepo;
	
	Locale locale = LocaleContextHolder.getLocale();

	private final String TRX_AMT = "TrxAmt";
	private final String FEE = "Fee";
	private final String TRX_COUNT = "TrxCount";
	
	@Override
	public void doGenerateReport(Map<String, Object> map, String requestBy)
			throws ApplicationException, BusinessException {
		String downloadId = (String) map.get("downloadId");
		
		try {
			//update report to in progress
			pendingDownloadService.updateToInProgress(downloadId);
			//-----------------------------
			
			Date fromDate = (Date) map.get("fromDate");
			Date toDate = (Date) map.get("toDate");
			String fileFormat = (String) map.get("fileFormat");
			String fileName = (String) map.get(ApplicationConstants.FILENAME);
			
			SimpleDateFormat sdfDateTime = new SimpleDateFormat("dd MMM yyyy HH:mm:ss");
			SimpleDateFormat sdfDate = new SimpleDateFormat("dd MMM yyyy");
			
			java.sql.Date startDateSql = new java.sql.Date(fromDate.getTime());
			java.sql.Date endDateSql = new java.sql.Date(toDate.getTime());
					
			Map<String, Object> reportInfo = getReportParams(fileFormat, map, startDateSql, endDateSql);

			String generateInfo = "generated by ".concat(requestBy).concat(" on ").concat(sdfDateTime.format(DateUtils.getCurrentTimestamp()));
			String periods = "Order Period ".concat(sdfDate.format(fromDate)).concat(" - ").concat(sdfDate.format(toDate));
			
			reportInfo.put("generateInfo", generateInfo);
			reportInfo.put("periods", periods);
	        
			String destinationFile = pathDownload + File.separator + fileName;
			generateReport(reportInfo, destinationFile, fileFormat);
			
			pendingDownloadService.updateToComplete(downloadId, destinationFile);
			
		} catch (BusinessException e) {
			pendingDownloadService.updateToNewRequest(downloadId);
			logger.error("Failed to generateReport with downloadId " + downloadId + " " + e.getMessage(),e);
		} catch (Exception e) {
			pendingDownloadService.updateToNewRequest(downloadId);
			logger.error("Failed to generateReport with downloadId " + downloadId + " " + e.getMessage(),e);
		}
		
	}
	
	@Override
	public Map<String, Object> downloadReport(Map<String, Object> map, String requestBy) throws ApplicationException {
		try {
			String downloadId = (String) map.get("downloadId");
			return pendingDownloadService.downloadReport(downloadId, requestBy);
		} catch (Exception e) {
			throw new ApplicationException(e);
		}
	}
	
	@Override
	public Map<String, Object> getDomServiceList() {
		Map<String, Object> resultMap = new HashMap<>();
		List<Map<String, String>> resultList = new ArrayList<>();
		try {
			List<Object[]> services = serviceRepo.findDomesticService();
			if (services!= null) {
				for(Object[] srvcObj : services ) {
					Map<String, String> map = new HashMap<>();
					map.put("srvcCd", (String) srvcObj[0]);
					map.put("srvcNm", (String) srvcObj[1]);
					resultList.add(map);
				}
			}
		} catch (Exception e) {
			logger.error("ERROR getDomServiceList due to="+e.getMessage());
		}
		resultMap.put("result", resultList);
		return resultMap;
	}
	
	private Map<String, Object> getReportParams(String fileFormat, Map<String, Object> reportParams, java.sql.Date startDate, java.sql.Date endDate) 
			throws Exception{
		
		reportParams.put("creationDateFrom", startDate);
		reportParams.put("creationDateTo", endDate);
		
		List<CorporateUserPendingTaskModel> resultList = domeRepo.findDomesticReport(reportParams);
		List<DomReportBean> detailDSList = new ArrayList<>();
		if(resultList != null && !resultList.isEmpty()) {
			DecimalFormat df = new DecimalFormat(moneyFormat);
			DomReportBean domReport = null;
			DomesticTransferModel domModel = null;
			int record = 1;
			for (CorporateUserPendingTaskModel pendingTask : resultList) {	
				String menuCd = pendingTask.getMenu().getCode();
				domReport = new DomReportBean();
				
				Map map = objectMapper.readValue(pendingTask.getValuesStr(), HashMap.class);
				
				if (pendingTask.getInstructionMode().equals(ApplicationConstants.SI_RECURRING)) {
					List<DomesticTransferModel> listModel = domTransferRepo.findRecurringTransactionForReport(pendingTask.getId(), new Timestamp(startDate.getTime()),  new Timestamp(endDate.getTime()));
					
					for (DomesticTransferModel domTransfer : listModel) {
						domReport = new DomReportBean();
						domReport.setHostRefNo(domTransfer.getHostReferenceNo());
						domReport.setRetrievalRefNo(domTransfer.getTrxReferenceNo());
						domReport.setNo(String.valueOf(record));
						domReport.setFileFormat(fileFormat);
						
						domReport.setRefNo(domTransfer.getReferenceNo());
						domReport.setCreatedDt(domTransfer.getCreatedDate());
						domReport.setInstructionDt(domTransfer.getInstructionDate());
						domReport.setInstructionMode(domTransfer.getInstructionMode());
						domReport.setStatus(message.getMessage(pendingTask.getTrxStatus().name(), null, locale));
						domReport.setRecurring(ApplicationConstants.YES);
						domReport.setReccuringEvery(domTransfer.getRecurringParamType());
						domReport.setReccurringStartDt(domTransfer.getRecurringStartDate());
						domReport.setReccurringEndDt(domTransfer.getRecurringEndDate());
						
						String srvc = getDomesticServiceFromServiceCd(domTransfer.getService().getCode());
						
						BigDecimal trxAmt = pendingTask.getTransactionAmount();
						BigDecimal fee = pendingTask.getTotalChargeEquivalentAmount();
						
						domReport.setSrvcCd(domTransfer.getService().getCode());
						domReport.setCorpId(domTransfer.getCorporate().getId());
						
						String userId = (String) domTransfer.getCreatedBy();
						if (userId.indexOf(ApplicationConstants.DELIMITER_PIPE) > -1) {
							userId = userId.split("\\|")[1];
						}
						domReport.setUserId(userId);
						
						domReport.setSourceAcctNo(domTransfer.getSourceAccount().getAccountNo());
						domReport.setSourceAcctNm(pendingTask.getSourceAccountName());
						domReport.setBenAcctNo(domTransfer.getBenAccountNo());
						domReport.setBenAcctNm(domTransfer.getBenAccountName());
						domReport.setBenAcctAlias(domTransfer.getBenAliasName());
						domReport.setBenAddress1(domTransfer.getBenAddr1());
						domReport.setBenAddress2(domTransfer.getBenAddr2());
						domReport.setBenAddress3(domTransfer.getBenAddr3());
						domReport.setBenBankCd(domTransfer.getBenDomesticBankCode().getCode());
						domReport.setBenBankName(domTransfer.getBenDomesticBankCode().getName());
						
						String chargeIns = (String) map.get("chargeInstruction");
						domReport.setChargeIns(chargeIns);
						domReport.setTrxAmt(trxAmt);
						domReport.setDebitAmt(trxAmt);
						domReport.setFee(fee);
						domReport.setTotalAmt(pendingTask.getTotalDebitedEquivalentAmount());
						domReport.setCurrency(pendingTask.getTransactionCurrency());
						domReport.setDesc(domTransfer.getRemark1());
						domReport.setSenderRefNo(domTransfer.getSenderRefNo());
						domReport.setBenRefNo(domTransfer.getBenRefNo());
						domReport.setIsFinal(domTransfer.getIsFinalPayment());
						
						domReport.setIsResident(domTransfer.getLldIsBenResidence());
						domReport.setResident(domTransfer.getLldBenResidenceCountry().getName());
						domReport.setIsCitizen(domTransfer.getLldIsBenCitizen());
						domReport.setCitizen(domTransfer.getLldBenCitizenCountry().getName());
						
						if (menuCd.equals("MNU_GPCASH_F_SIPKD")) {
							domReport.setBenType((String) map.get("beneficairyTypeName"));
						} else {
							domReport.setBenType((String) ((Map) map.get("confirm_data")).get("beneficairyType"));
						}
						domReport.setIsNotifyBen(domTransfer.getIsNotifyBen());
						domReport.setNotifyBenValue(domTransfer.getNotifyBenValue());
						
						String keyTrxType = srvc + chargeIns;
						String trxAmtKey = keyTrxType+TRX_AMT;
						String feeKey = keyTrxType+FEE;
						String trxCountKey = keyTrxType+TRX_COUNT;
						
						if(reportParams.get(trxAmtKey)!= null ) {
							reportParams.put(trxAmtKey, ((BigDecimal) reportParams.get(trxAmtKey)).add(trxAmt));
						} else {					
							reportParams.put(trxAmtKey, trxAmt);
						}
						
						if(reportParams.get(feeKey)!= null ) {
							reportParams.put(feeKey, ((BigDecimal) reportParams.get(feeKey)).add(fee));
						} else {					
							reportParams.put(feeKey, fee);
						}
						
						if(reportParams.get(trxCountKey)!= null ) {
							reportParams.put(trxCountKey, ((int) reportParams.get(trxCountKey))+1);
						} else {					
							reportParams.put(trxCountKey, 1);
						}
						
						detailDSList.add(domReport);
						record++;
						
					}
				} else {
					
					domReport.setHostRefNo(pendingTask.getHostRefNo());
					domReport.setRetrievalRefNo(pendingTask.getRetrievalRefNo());
					
					domModel = domTransferRepo.findByPendingTaskIdAndIsProcessed(pendingTask.getId(), ApplicationConstants.YES);
					if (domModel != null) {
						domReport.setHostRefNo(domModel.getHostReferenceNo());
						domReport.setRetrievalRefNo(domModel.getTrxReferenceNo());
					}
					
				domReport.setFileFormat(fileFormat);
				domReport.setNo(String.valueOf(record));
				
				domReport.setRefNo(pendingTask.getReferenceNo());
				domReport.setCreatedDt(pendingTask.getCreatedDate());
				domReport.setInstructionDt(pendingTask.getInstructionDate());
				domReport.setInstructionMode( pendingTask.getInstructionMode());
				domReport.setStatus(message.getMessage(pendingTask.getTrxStatus().name(), null, locale));
				
				if(pendingTask.getRecurringParam() != null && (pendingTask.getRecurringParam()) == 1 ) { //recurringParam
					domReport.setRecurring(ApplicationConstants.YES);
				} else {
					domReport.setRecurring(ApplicationConstants.NO);
				}
				
				domReport.setReccuringEvery(pendingTask.getRecurringParamType());
				domReport.setReccurringStartDt(pendingTask.getRecurringStartDate());
				domReport.setReccurringEndDt(pendingTask.getRecurringEndDate());
				
				String serviceCode = pendingTask.getTransactionService().getCode();
				
				String srvc = getDomesticServiceFromServiceCd(serviceCode);
				
				BigDecimal trxAmt = pendingTask.getTransactionAmount();
				BigDecimal fee = pendingTask.getTotalChargeEquivalentAmount();
				
				domReport.setSrvcCd(serviceCode);
				domReport.setCorpId(pendingTask.getCorporate().getId());
				
				String userId = (String) pendingTask.getCreatedBy();
				if (userId.indexOf(ApplicationConstants.DELIMITER_PIPE) > -1) {
					userId = userId.split("\\|")[1];
				}
				domReport.setUserId(userId);
				
				domReport.setSourceAcctNo(pendingTask.getSourceAccount());
				domReport.setSourceAcctNm(pendingTask.getSourceAccountName());
				domReport.setBenAcctNo(pendingTask.getBenAccount());
				domReport.setBenAcctNm(pendingTask.getBenAccountName());
				domReport.setBenAcctAlias((String) map.get("benAliasName"));
				domReport.setBenAddress1((String) map.get("address1"));
				domReport.setBenAddress2((String) map.get("address2"));
				domReport.setBenAddress3((String) map.get("address3"));
				
				domReport.setBenBankCd(pendingTask.getBenBankCode());
				if(map.get("destinationBank")!= null) {
					domReport.setBenBankName((String) map.get("destinationBank"));
				} else {
					domReport.setBenBankName((String) ((Map) map.get("confirm_data")).get("destinationBank"));
				}
				
				String chargeIns = (String) map.get("chargeInstruction");
				domReport.setChargeIns(chargeIns);
				domReport.setTrxAmt(trxAmt);
				domReport.setDebitAmt(trxAmt);
				domReport.setFee(fee);
				domReport.setTotalAmt(pendingTask.getTotalDebitedEquivalentAmount());
				domReport.setCurrency(pendingTask.getTransactionCurrency());
				domReport.setDesc(pendingTask.getRemark1());
				domReport.setSenderRefNo(pendingTask.getSenderRefNo());
				domReport.setBenRefNo(pendingTask.getBenRefNo());
				domReport.setIsFinal(pendingTask.getIsFinalPayment());
				
				domReport.setIsResident((String) map.get("isBenResident"));
				if(ApplicationConstants.YES.equals(domReport.getIsResident())) {
					domReport.setResident("INDONESIA");
				} else {
					domReport.setResident((String) map.get("benCitizenCountryName"));
				}
				
				domReport.setIsCitizen((String) map.get("isBenCitizen"));
				if(ApplicationConstants.YES.equals(domReport.getIsResident())) {
					domReport.setCitizen("INDONESIA");
				} else {
					domReport.setCitizen((String) map.get("benCitizenCountryName"));
				}
				
				if (menuCd.equals("MNU_GPCASH_F_SIPKD")) {
					domReport.setBenType((String) map.get("beneficairyTypeName"));
				} else {
					domReport.setBenType((String) ((Map) map.get("confirm_data")).get("beneficairyType"));
				}
				domReport.setIsNotifyBen((String) map.get("isNotify"));
				domReport.setNotifyBenValue((String) map.get("notifyBenValue"));
				
				String keyTrxType = srvc + chargeIns;
				String trxAmtKey = keyTrxType+TRX_AMT;
				String feeKey = keyTrxType+FEE;
				String trxCountKey = keyTrxType+TRX_COUNT;
				
				if(reportParams.get(trxAmtKey)!= null ) {
					reportParams.put(trxAmtKey, ((BigDecimal) reportParams.get(trxAmtKey)).add(trxAmt));
				} else {					
					reportParams.put(trxAmtKey, trxAmt);
				}
				
				if(reportParams.get(feeKey)!= null ) {
					reportParams.put(feeKey, ((BigDecimal) reportParams.get(feeKey)).add(fee));
				} else {					
					reportParams.put(feeKey, fee);
				}
				
				if(reportParams.get(trxCountKey)!= null ) {
					reportParams.put(trxCountKey, ((int) reportParams.get(trxCountKey))+1);
				} else {					
					reportParams.put(trxCountKey, 1);
				}
				
				detailDSList.add(domReport);
				record++;
			}
		}
		}
		
		JRBeanCollectionDataSource detailDataSource= new JRBeanCollectionDataSource(detailDSList);
		reportParams.put("detailDataSource", detailDataSource);
		reportParams.put("detailDSList", detailDSList);
		
		this.calculateTotalBigDecimal(reportParams, "sknTotalTrxAmt", "sknBENTrxAmt", "sknOURTrxAmt");
		this.calculateTotalBigDecimal(reportParams, "sknTotalFee", "sknBENFee", "sknOURFee");
		this.calculateTotalInt(reportParams, "sknTotalTrxCount", "sknBENTrxCount", "sknOURTrxCount");
		
		this.calculateTotalBigDecimal(reportParams, "rtgsTotalTrxAmt", "rtgsBENTrxAmt", "rtgsOURTrxAmt");
		this.calculateTotalBigDecimal(reportParams, "rtgsTotalFee", "rtgsBENFee", "rtgsOURFee");
		this.calculateTotalInt(reportParams, "rtgsTotalTrxCount", "rtgsBENTrxCount", "rtgsOURTrxCount");
		
		this.calculateTotalBigDecimal(reportParams, "onlineTotalTrxAmt", "onlineBENTrxAmt", "onlineOURTrxAmt");
		this.calculateTotalBigDecimal(reportParams, "onlineTotalFee", "onlineBENFee", "onlineOURFee");
		this.calculateTotalInt(reportParams, "onlineTotalTrxCount", "onlineBENTrxCount", "onlineOURTrxCount");
		
		return reportParams;
	}
	
	private void generateReport(Map<String, Object> parameters,
			String destinationFile,
			String fileFormat) throws Exception {
		
		String masterReportFile = reportFolder + File.separator + "BankReport" + File.separator + "DomReport" + File.separator + "domreport" + "-" + locale.getLanguage() + ".jasper";;
		JasperReport masterReport = (JasperReport) JRLoader.loadObject(new File(masterReportFile));
		
		//put subReport and fileFormat
		parameters.put("fileFormat", fileFormat);
		
		JasperPrint print = JasperFillManager.fillReport(masterReport, parameters, new JREmptyDataSource());
		
		Path destinationFilePath = Paths.get(destinationFile);
		
		if(fileFormat.equals(ApplicationConstants.FILE_FORMAT_EXCEL)) {
            JRXlsExporter xlsExporter = new JRXlsExporter();
            xlsExporter.setExporterInput(new SimpleExporterInput(print));
            xlsExporter.setExporterOutput(new SimpleOutputStreamExporterOutput(destinationFilePath.toFile()));
            SimpleXlsxReportConfiguration xlsReportConfiguration = new SimpleXlsxReportConfiguration();
            xlsReportConfiguration.setOnePagePerSheet(false);
            xlsReportConfiguration.setDetectCellType(true);
            xlsReportConfiguration.setWhitePageBackground(false);
            xlsReportConfiguration.setShowGridLines(false);
            xlsReportConfiguration.setRemoveEmptySpaceBetweenRows(true);
            xlsExporter.setConfiguration(xlsReportConfiguration);
            xlsExporter.exportReport();
		} else {
			Files.write(destinationFilePath, this.constructTextFile(parameters));
		}
	}
	
	private String getDomesticServiceFromServiceCd(String srvcCd) {
		if (srvcCd.indexOf("LLG") > -1) {
			return "skn";
		} else if(srvcCd.indexOf("RTGS") > -1) {
			return "rtgs";
		} else if(srvcCd.indexOf("ONLINE") > -1) {
			return "online";
		}
		
		return null;
	}
	
	private Map<String, Object> calculateTotalBigDecimal(Map<String, Object> inputMap, String key, String key1, String key2) {
		
		BigDecimal keyb1 =  inputMap.get(key1) != null ? (BigDecimal) inputMap.get(key1) : new BigDecimal(0);
		BigDecimal keyb2 =  inputMap.get(key2) != null ? (BigDecimal) inputMap.get(key2) : new BigDecimal(0);
		
		inputMap.put(key, keyb1.add(keyb2));
		
		return inputMap;
	}
	
	private Map<String, Object> calculateTotalInt(Map<String, Object> inputMap, String key, String key1, String key2) {
		
		int keyb1 =  inputMap.get(key1) != null ? (int) inputMap.get(key1) : 0;
		int keyb2 =  inputMap.get(key2) != null ? (int) inputMap.get(key2) : 0;
		
		inputMap.put(key, keyb1+keyb2);
		
		return inputMap;
	}
	
	private byte[] constructTextFile(Map<String, Object> parameters) {
		StringBuilder sb = new StringBuilder();
		@SuppressWarnings("unchecked")
		List<DomReportBean> detailDSList = (List<DomReportBean>) parameters.get("detailDSList");
		int count = 1;
		for(DomReportBean detail: detailDSList) {
			if(count==1) {
				sb.append(detail.getHeader());
			}
			
			sb.append("\n");
			sb.append(detail.toString());
			count++;
		}
		
		return sb.toString().getBytes();
	}
}
